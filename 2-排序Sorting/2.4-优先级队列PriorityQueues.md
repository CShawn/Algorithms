## 优先级队列PriorityQueues
对于一个列表中不同优先级的元素，有时会有这样的操作：每次取优先级最高的元素执行相应操作并移除，下次再取剩余元素中优先级最高的元素，继续操作；向列表中插入元素时，尽可能将优先级高的放到靠前的位置。即需要一种数据结构支持两种操作：删除最大元素和插入元素，这种数据类型叫**优先队列**。

### 实现优先队列
#### 数组实现（[无序](UnorderedArrayMaxPQ.java)）
插入元素：直接插入
删除最大元素：先对列表进行排序（选择排序），再删除最大元素

#### 数组实现（[有序](OrderedArrayMaxPQ.java)）
插入元素：插入元素后将最大的元素移动到最边上，类似于插入排序
删除最大元素：直接删除

#### 链表实现
插入元素：插入元素后将最大的元素移到链表头
删除最大元素：直接删除

#### 二叉堆
一棵完全二叉树，其每个结点都大于它的叶子节点，根结点最大，称为**最大堆**；其每个结点都小于它的叶子节点，根结点最小，称为**最小堆**；二者合称**二叉堆**。

二叉堆可以用数组表示，一个长度为N的数组，从索引`1`开始，到`N`；按层放置，根节点为1，根节点的两个子结节为2和3，则第`k`个节点的子节点为`2k`和`2k+1`，而父节点为`k/2`。所以，正是为了方便计算父子节点，索引从`1`开始。

使用二叉堆实现优先级队列很显然要高效的多，使用最大堆，删除最大元素时只用删除根节点，插入元素时，将元素插入队尾；之后，再将最大堆排序。那么，删除和插入之后该怎么排序呢？
##### 上浮swim
在队尾插入元素后，有可能这个元素比上层的节点大，此时就需要将元素层层上浮，到达它应处于的位置。只用不断和其父节点比较，若比父节点大，则两者交换即可。
```
private void swim(int k) {
    while (k > 1 && less(k/2, k)) {
        exch(k/2, k);
        // 更新k值，继续向上比较
        k = k/2;
    }
}
```

##### 下沉sink
删除了最大元素后，根节点空缺，就需要一个节点补空，我们可将最后一个节点（数组末尾节点）放到根节点位置上；之后，同理需要将此节点层层下沉到达它应处于的位置。
```
private void sink(int k) {
    while (2*k <= N) {
        int j = 2*k;
        // 判断左右两个子节点哪个更大
        if (j < N && less(j, j+1)) j++;
        // 比较k是否比其两个子节点中较大者小
        // 若k较大，则break结束
        if (!less(k, j)) break;
        // 若k较小则交换
        exch(k, j);
        // 更新k值，继续向下比较
        k = j;
    }
}
```

##### 使用二叉堆实现优先级队列
可实现两种优先级队列[MaxPQ](MaxPQ.java)和[MinPQ](MinPQ.java)
```
public class MaxPQ<Key extends Comparable<Key>> {
    private Key[] pq; // heap-ordered complete binary tree
    private int N = 0; // in pq[1..N] with pq[0] unused
    public MaxPQ(int maxN) {
        pq = (Key[]) new Comparable[maxN+1];
    }
    public boolean isEmpty() {
        return N == 0;
    }
    public int size() { 
        return N;
    }
    public void insert(Key v) {
        pq[++N] = v;
        swim(N);
    }
    public Key delMax() {
        Key max = pq[1]; // Retrieve max key from top.
        exch(1, N--); // Exchange with last item.
        pq[N+1] = null; // Avoid loitering.
        sink(1); // Restore heap property.
        return max;
    }
}
```
插入元素，比较：`lgN+1`次
删除最大元素，比较：`2lgN`次

##### 索引优先队列
### 堆排序
